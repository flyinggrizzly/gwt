#!/bin/zsh

function gwt() {
  local worktrees_path="$HOME/worktrees"

  local subcommand=$1
  local params=("${(@)argv[2,-1]}")

  local DRY_RUN=""
  if [[ ${params[(r)--dry-run]} == "--dry-run" ]]; then
    DRY_RUN="echo"
    params=(${params:#--dry-run})
  fi

  _get_main_repo() {
    local main_repo=""
    while IFS= read -r worktree_line; do
      local wt_path="$(echo "$worktree_line" | awk '{print $1}')"

      # The main worktree has a .git **directory**, whereas linked worktrees have
      # symlinks to the parent's .git/wortkrees/<branchname>
      if [[ -n "$wt_path" && -d "$wt_path/.git" ]]; then
        main_repo="$wt_path"
        break
      fi
    done < <(git worktree list)
    echo "$main_repo"
  }

  _get_all_worktrees() {
    local include_main=false
    if ([[ ${params[(r)-m]} == "-m" ]] || [[ ${params[(r)--with-main]} == "--with-main" ]]); then
      include_main=true
    fi

    local main_repo_path="$(_get_main_repo)"

    git worktree list --porcelain | awk -v main_path="$main_repo_path" -v include_main="$include_main" '
      /^worktree / { wt_path = substr($0, 10) }
      /^branch / { branch = substr($0, 8); gsub(/^refs\/heads\//, "", branch) }
      /^$/ {
        if (wt_path && branch && (include_main == "true" || wt_path != main_path)) {
          print branch ":" wt_path
        }
        wt_path=""; branch=""
      }
      END {
        if (wt_path && branch && (include_main == "true" || wt_path != main_path)) {
          print branch ":" wt_path
        }
      }
    '
  }

  _worktree_exists() {
    local branch="$1"
    while IFS=':' read -r wt_branch wt_path; do
      if [[ "$wt_branch" == "$branch" ]]; then
        return 0
      fi
    done < <(_get_all_worktrees)
    return 1
  }

  _branch_exists() {
    local branch="$1"
    git show-ref --verify --quiet "refs/heads/$branch"
  }

  _get_repo_name() {
    basename "$(git rev-parse --show-toplevel 2>/dev/null)"
  }

  _build_worktrees_repo_path() {
    local repo_name="$(_get_repo_name)"
    echo "$worktrees_path/$repo_name"
  }

  _build_worktree_path() {
    echo "$(_build_worktrees_repo_path)/$1"
  }

  _create() {
    local create_branch=false
    local branch_name=""
    local and_cd=false

    while [[ $# -gt 0 ]]; do
      case $1 in
        -b)
          create_branch=true
          shift
          ;;
        --cd)
          and_cd=true
          shift
          ;;
        *)
          branch_name="$1"
          shift
          ;;
      esac
    done

    $DRY_RUN mkdir -p "$(_build_worktrees_repo_path)"

    if [[ $create_branch == true ]]; then
      if _branch_exists $branch_name; then
        echo "Branch '$branch_name' already exists."
        return 1
      fi

      $DRY_RUN git worktree add -b "$branch_name" "$(_build_worktree_path $branch_name)"
    else
      if ! _branch_exists $branch_name; then
        echo "Branch '$branch_name' does not exist."
        return 1
      fi

      $DRY_RUN git worktree add "$(_build_worktree_path $branch_name)" "$branch_name"
    fi

    if [[ $and_cd == true ]]; then
      _cd "$branch_name"
    else
      return 0
    fi
  }

  _cd() {
    if [[ $# -eq 0 ]]; then
      local main_repo="$(_get_main_repo)"

      $DRY_RUN cd "$main_repo"
      return 0
    elif [[ $# -eq 1 ]]; then
      local branch_name="$1"

      if ! _worktree_exists $branch_name; then
        echo "Worktree for branch '$branch_name' does not exist."
        return 1
      fi

      $DRY_RUN cd "$(_build_worktree_path $branch_name)"
      return 0
    else
      echo "Usage: gwt cd [branch_name]"
      return 1
    fi
  }

  case $subcommand in
    add|a)
      _create "${(@)params}"
      ;;
    cd|co) # If a worktree exists, we treat cd and checkout as the same operation for convenience
      _cd "${(@)params}"
      ;;
    map)
      _get_all_worktrees "${(@)params}"
      ;;
  esac
}

