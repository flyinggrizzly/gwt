#!/bin/zsh

function gwt() {
  local worktrees_path="$HOME/worktrees"

  local subcommand=$1
  local params=("${(@)argv[2,-1]}")

  local DRY_RUN=""
  if [[ ${params[(r)--dry-run]} == "--dry-run" ]]; then
    DRY_RUN="echo"
    params=(${params:#--dry-run})
  fi

  _get_main_repo() {
    local main_repo=""
    while IFS= read -r worktree_line; do
      local wt_path="$(echo "$worktree_line" | awk '{print $1}')"

      # The main worktree has a .git **directory**, whereas linked worktrees have
      # symlinks to the parent's .git/wortkrees/<branchname>
      if [[ -n "$wt_path" && -d "$wt_path/.git" ]]; then
        main_repo="$wt_path"
        break
      fi
    done < <(git worktree list)
    echo "$main_repo"
  }

  _get_all_worktrees() {
    local include_main=false
    if ([[ ${params[(r)-m]} == "-m" ]] || [[ ${params[(r)--with-main]} == "--with-main" ]]); then
      include_main=true
    fi

    local main_repo_path="$(_get_main_repo)"

    git worktree list --porcelain | awk -v main_path="$main_repo_path" -v include_main="$include_main" '
      /^worktree / { wt_path = substr($0, 10) }
      /^branch / { branch = substr($0, 8); gsub(/^refs\/heads\//, "", branch) }
      /^$/ {
        if (wt_path && branch && (include_main == "true" || wt_path != main_path)) {
          print branch ":" wt_path
        }
        wt_path=""; branch=""
      }
      END {
        if (wt_path && branch && (include_main == "true" || wt_path != main_path)) {
          print branch ":" wt_path
        }
      }
    '
  }

  _worktree_path_for() {
    local branch="$1"
    while IFS=':' read -r wt_branch wt_path; do
      if [[ "$wt_branch" == "$branch" ]]; then
        echo $wt_path
        # Early return is safe since git itself enforces a 1:1 of branch:worktree
        return 0
      fi
    done < <(_get_all_worktrees)
    return 1
  }

  _worktree_exists() {
    _worktree_path_for "$1" >/dev/null 2>&1
  }

  _branch_exists() {
    local branch="$1"
    git show-ref --verify --quiet "refs/heads/$branch"
  }

  _get_repo_name() {
    basename "$(git rev-parse --show-toplevel 2>/dev/null)"
  }

  _build_worktree_path() {
    echo "$worktrees_path/$(_get_repo_name)/$1"
  }

  _worktree_type() {
    local branch="$1"
    if _worktree_exists "$branch"; then
      local worktree_path="$(_worktree_path_for "$branch")"
      if [[ -d "$worktree_path/.git" ]]; then
        echo "main"
      else
        echo "linked"
      fi
      return 0
    else
      return 1
    fi
  }

  _has_unpushed_changes() {
    local branch="$1"

    local upstream=$(git rev-parse --abbrev-ref "$branch@{upstream}" 2>/dev/null)

    if [[ -z "$upstream" ]]; then
      return 1
    fi

    if [[ -n $(git log "$upstream..$branch" --oneline 2>/dev/null) ]]; then
      return 0
    else
      return 1
    fi
  }

  # Helper function to check if worktree is dirty
  _is_dirty() {
    local branch="$1"
    local current_branch=$(git branch --show-current 2>/dev/null)

    # If it's the current branch, check working directory status
    if [[ "$branch" == "$current_branch" ]]; then
      [[ -n $(git status --porcelain --untracked-files=no 2>/dev/null) ]]
    else
      # Check if there's a worktree for this branch
      local worktree_path=$(git worktree list --porcelain 2>/dev/null | awk -v branch="$branch" '
      /^worktree/ { path = $2 }
      /^branch/ && $2 == "refs/heads/" branch { print path; exit }
      ')

      if [[ -n "$worktree_path" ]]; then
        # Check status in the worktree
        [[ -n $(git -C "$worktree_path" status --porcelain --untracked-files=no 2>/dev/null) ]]
      else
        # No worktree for this branch
        return 1
      fi
    fi
  }

  _has_untracked() {
    local branch="$1"
    local current_branch=$(git branch --show-current 2>/dev/null)
    # If it's the current branch, check for untracked files
    if [[ "$branch" == "$current_branch" ]]; then
      [[ -n $(git ls-files --others --exclude-standard 2>/dev/null) ]]
    else
      # Check if there's a worktree for this branch
      local worktree_path=$(git worktree list --porcelain 2>/dev/null | awk -v branch="$branch" '
        /^worktree/ { path = $2 }
        /^branch/ && $2 == "refs/heads/" branch { print path; exit }
      ')
      if [[ -n "$worktree_path" ]]; then
        # Check for untracked files in the worktree
        [[ -n $(git -C "$worktree_path" ls-files --others --exclude-standard 2>/dev/null) ]]
      else
        # No worktree for this branch
        return 1
      fi
    fi
  }

  _worktree_status() {
    local branch="$1"
    if ! _worktree_exists "$branch"; then
      return 1
    fi

    local status_string=()

    if _is_dirty "$branch"; then
      status_string+=("dirty")
    fi

    if _has_unpushed_changes "$branch"; then
      status_string+=("unpushed")
    fi

    if [[ ${#status_string[@]} -eq 0 ]]; then
      echo "clean"
    else
      echo "${(j: + :)status_string}"
    fi
  }

  _resolve_branch_from_branch_or_path() {
    local branch_or_path="$1"
    if [[ "$branch_or_path" == /* || "$branch_or_path" == ~* || "$branch_or_path" == .* ]]; then
      local abs_path="$(realpath "$input" 2>/dev/null || echo "$input")"

      while IFS=':' read -r branch worktree_path; do
        if [[ "$abs_path" == "$worktree_path" ]]; then
          echo "$branch"
          return 0
        fi
      done < <(_get_all_worktrees)

      # Don't try do delete the main worktree
      local main_repo="$(_get_main_repo)"
      if [[ "$abs_path" == "$main_repo" ]]; then
        echo "Error: Cannot delete the main worktree" >&2
        return 1
      fi

      echo "Error: Path '$input' does not resolve to a worktree" >&2
      return 1
    else
      echo "$branch_or_path"
      return 0
    fi
  }

  _create() {
    local create_branch=false
    local branch_name=""
    local and_cd=false
    local custom_path=""

    while [[ $# -gt 0 ]]; do
      case $1 in
        -b)
          create_branch=true
          shift
          ;;
        --cd)
          and_cd=true
          shift
          ;;
        --path|-p)
          custom_path="$2"
          shift 2
          ;;
        *)
          branch_name="$1"
          shift
          ;;
      esac
    done

    local worktree_path=${custom_path:-$(_build_worktree_path $branch_name)}
    local worktree_parent_path=${worktree_path:h}

    $DRY_RUN mkdir -p "$worktree_parent_path"

    if [[ $create_branch == true ]]; then
      if _branch_exists $branch_name; then
        echo "Branch '$branch_name' already exists."
        return 1
      fi

      $DRY_RUN git worktree add -b "$branch_name" "$worktree_path"
    else
      if ! _branch_exists $branch_name; then
        echo "Branch '$branch_name' does not exist."
        return 1
      fi

      $DRY_RUN git worktree add "$worktree_path" "$branch_name"
    fi

    if [[ $and_cd == true ]]; then
      _cd "$branch_name"
    else
      return 0
    fi
  }

  _cd() {
    if [[ $# -eq 0 ]]; then
      local main_repo="$(_get_main_repo)"

      $DRY_RUN cd "$main_repo"
      return 0
    elif [[ $# -eq 1 ]]; then
      local branch_name="$1"

      if ! _worktree_exists $branch_name; then
        echo "Worktree for branch '$branch_name' does not exist."
        return 1
      fi

      $DRY_RUN cd "$(_worktree_path_for $branch_name)"
      return 0
    else
      echo "Usage: gwt cd [branch_name]"
      return 1
    fi
  }

  _remove() {
    local branch_or_path="$1"
    local branch_name="$(_resolve_branch_from_branch_or_path $branch_or_path)"

    local force_remove=false

    if ! _branch_exists "$branch_name"; then
      echo "Branch '$branch_name' does not exist."
      return 1
    fi

    local rm_worktree_path="$(_worktree_path_for $branch_name)"

    local current_dir="$(pwd)"
      if [[ "$current_dir" == "$rm_worktree_path" ]]; then
      _cd # no args--go to parent. DRY_RUN will be handled by _cd
    fi

    if [[ $force_flag == true ]]; then
      $DRY_RUN git worktree remove -f "$rm_worktree_path"
    else
      local dirty="$(_is_dirty "$rm_worktree_path")"
      local unpushed_commits="$(_has_unpushed_changes "$branch_name")"

      if [[ $unpushed_commits == true ]]; then
        echo "Branch '$branch_name' has unpushed commits. Use --force to remove anyway."
        return 1
      fi

      $DRY_RUN git worktree remove "$rm_worktree_path"
    fi
  }

  _status() {
    local show_headers=true
    if [[ ${params[(r)--porcelain]} == "--porcelain" ]]; then
      show_headers=false
      params=(${params:#--porcelain})
    fi

    local show_type=false
    if ([[ ${params[(r)-m]} == "-m" ]] || [[ ${params[(r)--with-main]} == "--with-main" ]]); then
      show_type=true
    fi

    local status_string=""
    if [[ $show_headers == true ]]; then
      if [[ $show_type == true ]]; then
        status_string+="TYPE|"
      fi

      status_string+="BRANCH|PATH|STATE"
    fi

    while IFS=':' read -r wt_branch wt_path; do
      status_string+=$'\n'

      if [[ $show_type == true ]]; then
        status_string+=$(_worktree_type "$wt_branch")
        status_string+="|"
      fi

      status_string+="$wt_branch|$wt_path|$(_worktree_status $wt_branch)\n"
    done < <(_get_all_worktrees "${(@)params}") # passing params will surface -m|--with-main to _get_all_worktrees

    echo -e "$status_string" | column -t -s '|'
    return 0
  }

  case $subcommand in
    add|a)
      _create "${(@)params}"
      ;;
    cd|co) # If a worktree exists, we treat cd and checkout as the same operation for convenience
      _cd "${(@)params}"
      ;;
    remove|rm)
      _remove "${(@)params}"
      ;;
    status|st|s)
      _status "${(@)params}"
      ;;
    map)
      _get_all_worktrees "${(@)params}"
      ;;
  esac
}

