#!/bin/zsh

function gwt() {
  local WORKTREE_BASE="$HOME/worktrees"
  local AUTO_CD="false"
  local DELETE_BRANCH_WITH_TREE="false"

  local subcommand=""
  local params
  if [[ $1 == "--help" || $1 != -* ]]; then
    subcommand=$1
    params=("${(@)argv[2,-1]}")
  else
    params=("${(@)argv[@]}")
  fi

  local DRY_RUN=""
  if [[ ${params[(r)--dry-run]} == "--dry-run" ]]; then
    DRY_RUN="echo"
    params=(${params:#--dry-run})
  fi

  __gwt_load_user_settings() {
    local settings_file="$HOME/.config/gwt/settings.json"
    if [[ -f "$settings_file" ]]; then
      local settings=$(jq -r '.' "$settings_file" 2>/dev/null)
      if [[ $? -eq 0 ]]; then
        WORKTREE_BASE=$(echo "$settings" | jq -r '.worktreeLocation')
        AUTO_CD=$(echo "$settings" | jq -r '.autoCd')
        DELETE_BRANCH_WITH_TREE=$(echo "$settings" | jq -r '.deleteBranchWithTree')
      fi
    fi
  }

  __gwt_load_user_settings

  __gwt_get_main_repo() {
    local main_repo=""
    while IFS= read -r worktree_line; do
      local wt_path="$(echo "$worktree_line" | awk '{print $1}')"

      # The main worktree has a .git **directory**, whereas linked worktrees have
      # symlinks to the parent's .git/wortkrees/<branchname>
      if [[ -n "$wt_path" && -d "$wt_path/.git" ]]; then
        main_repo="$wt_path"
        break
      fi
    done < <(git worktree list)
    echo "$main_repo"
  }

  __gwt_get_all_worktrees() {
    local include_main=false
    if ([[ ${params[(r)-m]} == "-m" ]] || [[ ${params[(r)--with-main]} == "--with-main" ]]); then
      include_main=true
    fi

    local main_repo_path="$(__gwt_get_main_repo)"

    git worktree list --porcelain | awk -v main_path="$main_repo_path" -v include_main="$include_main" '
      /^worktree / { wt_path = substr($0, 10) }
      /^branch / { branch = substr($0, 8); gsub(/^refs\/heads\//, "", branch) }
      /^$/ {
        if (wt_path && branch && (include_main == "true" || wt_path != main_path)) {
          print branch ":" wt_path
        }
        wt_path=""; branch=""
      }
      END {
        if (wt_path && branch && (include_main == "true" || wt_path != main_path)) {
          print branch ":" wt_path
        }
      }
    '
  }

  __gwt_worktree_path_for() {
    local branch="$1"
    while IFS=':' read -r wt_branch wt_path; do
      if [[ "$wt_branch" == "$branch" ]]; then
        echo $wt_path
        # Early return is safe since git itself enforces a 1:1 of branch:worktree
        return 0
      fi
    done < <(__gwt_get_all_worktrees "${(@)params}")
    return 1
  }

  __gwt_worktree_exists() {
    __gwt_worktree_path_for "$1" >/dev/null 2>&1
  }

  __gwt_branch_exists() {
    local branch="$1"
    git show-ref --verify --quiet "refs/heads/$branch"
  }

  __gwt_get_repo_name() {
    basename "$(git rev-parse --show-toplevel 2>/dev/null)"
  }

  __gwt_get_repo_owner() {
    local remote_url=""

    # Try to get origin remote first
    remote_url=$(git remote get-url origin 2>/dev/null)

    # If no origin, get the first available remote
    if [[ -z "$remote_url" ]]; then
      remote_url=$(git remote -v 2>/dev/null | awk 'NR==1 {print $2}')
    fi

    # If no remotes at all, return empty
    if [[ -z "$remote_url" ]]; then
      echo ""
      return 0
    fi

    # Extract owner from URL
    local owner=""

    # SSH format: git@host:owner/repo or git@host:owner/repo.git
    if [[ "$remote_url" =~ ^git@[^:]+:([^/]+)/[^/]+(.git)?$ ]]; then
      owner="${match[1]}"
    # HTTPS format: https://host/owner/repo or https://host/owner/repo.git
    elif [[ "$remote_url" =~ ^https?://[^/]+/([^/]+)/[^/]+(.git)?$ ]]; then
      owner="${match[1]}"
    # SSH with ssh:// format: ssh://git@host/owner/repo or ssh://git@host:port/owner/repo
    elif [[ "$remote_url" =~ ^ssh://[^/]+/([^/]+)/[^/]+(.git)?$ ]]; then
      owner="${match[1]}"
    fi

    echo "$owner"
  }

  __gwt_build_worktree_path() {
    local owner="$(__gwt_get_repo_owner)"
    local repo_name="$(__gwt_get_repo_name)"

    if [[ -n "$owner" ]]; then
      echo "$WORKTREE_BASE/$owner/$repo_name/$1"
    else
      echo "$WORKTREE_BASE/$repo_name/$1"
    fi
  }

  __gwt_worktree_type() {
    local branch="$1"
    if __gwt_worktree_exists "$branch"; then
      local worktree_path="$(__gwt_worktree_path_for "$branch")"
      if [[ -d "$worktree_path/.git" ]]; then
        echo "main"
      else
        echo "linked"
      fi
      return 0
    else
      return 1
    fi
  }

  __gwt_has_unpushed_changes() {
    local branch="$1"

    local upstream=$(git rev-parse --abbrev-ref "$branch@{upstream}" 2>/dev/null)

    if [[ -z "$upstream" ]]; then
      return 1
    fi

    if [[ -n $(git log "$upstream..$branch" --oneline 2>/dev/null) ]]; then
      return 0
    else
      return 1
    fi
  }

  # Helper function to check if worktree is dirty
  __gwt_is_dirty() {
    local branch="$1"
    local current_branch=$(git branch --show-current 2>/dev/null)

    # If it's the current branch, check working directory status
    if [[ "$branch" == "$current_branch" ]]; then
      [[ -n $(git status --porcelain --untracked-files=no 2>/dev/null) ]]
    else
      # Check if there's a worktree for this branch
      local worktree_path=$(git worktree list --porcelain 2>/dev/null | awk -v branch="$branch" '
      /^worktree/ { path = $2 }
      /^branch/ && $2 == "refs/heads/" branch { print path; exit }
      ')

      if [[ -n "$worktree_path" ]]; then
        # Check status in the worktree
        [[ -n $(git -C "$worktree_path" status --porcelain --untracked-files=no 2>/dev/null) ]]
      else
        # No worktree for this branch
        return 1
      fi
    fi
  }

  __gwt_has_untracked() {
    local branch="$1"
    local current_branch=$(git branch --show-current 2>/dev/null)
    # If it's the current branch, check for untracked files
    if [[ "$branch" == "$current_branch" ]]; then
      [[ -n $(git ls-files --others --exclude-standard 2>/dev/null) ]]
    else
      # Check if there's a worktree for this branch
      local worktree_path=$(git worktree list --porcelain 2>/dev/null | awk -v branch="$branch" '
        /^worktree/ { path = $2 }
        /^branch/ && $2 == "refs/heads/" branch { print path; exit }
      ')
      if [[ -n "$worktree_path" ]]; then
        # Check for untracked files in the worktree
        [[ -n $(git -C "$worktree_path" ls-files --others --exclude-standard 2>/dev/null) ]]
      else
        # No worktree for this branch
        return 1
      fi
    fi
  }

  __gwt_worktree_status() {
    local branch="$1"
    if ! __gwt_worktree_exists "$branch"; then
      return 1
    fi

    local status_string=()

    if __gwt_is_dirty "$branch"; then
      status_string+=("dirty")
    fi

    if __gwt_has_unpushed_changes "$branch"; then
      status_string+=("unpushed")
    fi

    if [[ ${#status_string[@]} -eq 0 ]]; then
      echo "clean"
    else
      echo "${(j:,:)status_string}"
    fi
  }

  __gwt_resolve_branch_from_branch_or_path() {
    local branch_or_path="$1"
    if [[ "$branch_or_path" == /* || "$branch_or_path" == ~* || "$branch_or_path" == .* ]]; then
      local abs_path="$(realpath "$input" 2>/dev/null || echo "$input")"

      while IFS=':' read -r branch worktree_path; do
        if [[ "$abs_path" == "$worktree_path" ]]; then
          echo "$branch"
          return 0
        fi
      done < <(__gwt_get_all_worktrees)

      # Don't try do delete the main worktree
      local main_repo="$(__gwt_get_main_repo)"
      if [[ "$abs_path" == "$main_repo" ]]; then
        echo "Error: Cannot delete the main worktree" >&2
        return 1
      fi

      echo "Error: Path '$input' does not resolve to a worktree" >&2
      return 1
    else
      echo "$branch_or_path"
      return 0
    fi
  }

  __gwt_save_user_settings() {
    local default_location="$1"
    local auto_cd="$2"
    local delete_branch_with_tree="$3"
    local settings_dir="$HOME/.config/gwt"
    local settings_file="$settings_dir/settings.json"

    mkdir -p "$settings_dir"

    jq -n \
      --arg location "$default_location" \
      --argjson autocd "$auto_cd" \
      --argjson deletebranch "$delete_branch_with_tree" \
      '{worktreeLocation: $location, autoCd: $autocd, deleteBranchWithTree: $deletebranch}' \
      > "$settings_file"
  }

  __gwt_create() {
    local create_branch=false
    local branch_name=""
    local and_cd="$AUTO_CD"
    local custom_path=""

    while [[ $# -gt 0 ]]; do
      case $1 in
        -b)
          create_branch=true
          shift
          ;;
        --cd)
          and_cd=true
          shift
          ;;
        --no-cd)
          and_cd=false
          shift
          ;;
        --path|-p)
          custom_path="$2"
          shift 2
          ;;
        *)
          branch_name="$1"
          shift
          ;;
      esac
    done

    local worktree_path=${custom_path:-$(__gwt_build_worktree_path $branch_name)}
    local worktree_parent_path=${worktree_path:h}

    $DRY_RUN mkdir -p "$worktree_parent_path"

    if [[ $create_branch == true ]]; then
      if __gwt_branch_exists $branch_name; then
        echo "Branch '$branch_name' already exists."
        return 1
      fi

      $DRY_RUN git worktree add -b "$branch_name" "$worktree_path"
    else
      if ! __gwt_branch_exists $branch_name; then
        echo "Branch '$branch_name' does not exist."
        return 1
      fi

      $DRY_RUN git worktree add "$worktree_path" "$branch_name"
    fi

    if [[ $and_cd == true ]]; then
      __gwt_cd "$branch_name"
    else
      return 0
    fi
  }

  __gwt_cd() {
    if [[ $# -eq 0 ]]; then
      local main_repo="$(__gwt_get_main_repo)"

      $DRY_RUN cd "$main_repo"
      return 0
    elif [[ $# -eq 1 ]]; then
      local branch_name="$1"

      if ! __gwt_worktree_exists $branch_name; then
        echo "Worktree for branch '$branch_name' does not exist."
        return 1
      fi

      $DRY_RUN cd "$(__gwt_worktree_path_for $branch_name)"
      return 0
    else
      echo "Usage: gwt cd [branch_name]"
      return 1
    fi
  }

  __gwt_remove() {
    local branch_or_path="$1"
    local branch_name="$(__gwt_resolve_branch_from_branch_or_path $branch_or_path)"

    local force_remove=false
    if ([[ ${params[(r)--force]} == "--force" ]] || [[ ${params[(r)-f]} == "-f" ]]); then
      force_remove=true
      params=(${params:#-f})
      params=(${params:#--force})
    fi

    local rm_branch_after=$DELETE_BRANCH_WITH_TREE
    if ([[ ${params[(r)--delete-branch]} == "--delete-branch" ]] || [[ ${params[(r)-db]} == "-db" ]]); then
      rm_branch_after=true
      params=(${params:#-db})
      params=(${params:#--delete-branch})
    fi
    if ([[ ${params[(r)--preserve-branch]} == "--preserve-branch" ]] || [[ ${params[(r)-pb]} == "-pb" ]]); then
      rm_branch_after=false
      params=(${params:#-pb})
      params=(${params:#--preserve-branch})
    fi

    if ! __gwt_branch_exists "$branch_name"; then
      echo "Branch '$branch_name' does not exist."
      return 1
    fi

    local rm_worktree_path="$(__gwt_worktree_path_for $branch_name)"

    local current_dir="$(pwd)"
      if [[ "$current_dir" == "$rm_worktree_path" ]]; then
      __gwt_cd # no args--go to parent. DRY_RUN will be handled by __gwt_cd
    fi

    if [[ $force_remove == true ]]; then
      $DRY_RUN git worktree remove -f "$rm_worktree_path"

      if [[ $rm_branch_after == true ]]; then
        $DRY_RUN git branch -D "$branch_name"
      fi
    else
      local dirty="$(__gwt_is_dirty "$rm_worktree_path")"
      local unpushed_commits="$(__gwt_has_unpushed_changes "$branch_name")"

      if [[ $unpushed_commits == true ]]; then
        echo "Branch '$branch_name' has unpushed commits. Use --force to remove anyway."
        return 1
      fi

      $DRY_RUN git worktree remove "$rm_worktree_path"
      if [[ $rm_branch_after == true ]]; then
        $DRY_RUN git branch -d "$branch_name"
      fi
    fi
  }

  __gwt_status() {
    local show_headers=true
    if [[ ${params[(r)--porcelain]} == "--porcelain" ]]; then
      show_headers=false
      params=(${params:#--porcelain})
    fi

    local show_type=false
    if ([[ ${params[(r)-m]} == "-m" ]] || [[ ${params[(r)--with-main]} == "--with-main" ]]); then
      show_type=true
    fi

    local status_string=""
    if [[ $show_headers == true ]]; then
      if [[ $show_type == true ]]; then
        status_string+="TYPE|"
      fi

      status_string+="BRANCH|PATH|STATE"
    fi

    while IFS=':' read -r wt_branch wt_path; do
      status_string+=$'\n'

      if [[ $show_type == true ]]; then
        status_string+=$(__gwt_worktree_type "$wt_branch")
        status_string+="|"
      fi

      status_string+="$wt_branch|$wt_path|$(__gwt_worktree_status $wt_branch)"
    done < <(__gwt_get_all_worktrees "${(@)params}") # passing params will surface -m|--with-main to __gwt_get_all_worktrees


    echo -e "$status_string" | column -t -s '|'
    return 0
  }

  __gwt_clean() {
    while IFS=':' read -r wt_branch wt_path; do
      echo "Removing worktree for branch '$wt_branch' at '$wt_path'"
      __gwt_remove "$wt_branch"
    done < <(__gwt_get_all_worktrees)
  }

  __gwt_init() {
    echo "GWT Configuration Setup"
    echo "======================"
    echo

    # Configure default worktree location
    echo "Current default worktree location: $WORKTREE_BASE"
    echo -n "Enter new default worktree location (or press Enter to keep current): "
    read new_location

    if [[ -z "$new_location" ]]; then
      new_location="$WORKTREE_BASE"
    fi
    new_location="${new_location/#\~/$HOME}"

    # Configure auto-cd
    echo
    current_autocd="false"
    if [[ "$AUTO_CD" == "true" ]]; then
      current_autocd="true"
    fi
    echo "Current auto-cd setting: $current_autocd"
    if [[ "$AUTO_CD" == "true" ]]; then
      echo -n "Should 'gwt <branch>' automatically cd to the new worktree? (Y/n): "
    else
      echo -n "Should 'gwt <branch>' automatically cd to the new worktree? (y/N): "
    fi
    read autocd_input

    local autocd_setting="false"
    if [[ "$AUTO_CD" == "true" ]]; then
      if [[ ! "$autocd_input" =~ ^[Nn] ]]; then
        autocd_setting="true"
      fi
    else
      if [[ "$autocd_input" =~ ^[Yy] ]]; then
        autocd_setting="true"
      fi
    fi

    # Configure delete-branch-with-tree
    echo
    current_delete_branch="false"
    if [[ "$DELETE_BRANCH_WITH_TREE" == "true" ]]; then
      current_delete_branch="true"
    fi
    echo "Current delete-branch-with-tree setting: $current_delete_branch"
    if [[ "$DELETE_BRANCH_WITH_TREE" == "true" ]]; then
      echo -n "Should 'gwt -d' also delete the branch by default? (Y/n): "
    else
      echo -n "Should 'gwt -d' also delete the branch by default? (y/N): "
    fi
    read delete_branch_input

    local delete_branch_setting="false"
    if [[ "$DELETE_BRANCH_WITH_TREE" == "true" ]]; then
      if [[ ! "$delete_branch_input" =~ ^[Nn] ]]; then
        delete_branch_setting="true"
      fi
    else
      if [[ "$delete_branch_input" =~ ^[Yy] ]]; then
        delete_branch_setting="true"
      fi
    fi

    __gwt_save_user_settings "$new_location" "$autocd_setting" "$delete_branch_setting"

    echo
    echo "âœ“ Settings saved to ~/.config/gwt/settings.json"
    echo "  Default worktree location: $new_location"
    echo "  Auto-cd enabled: $autocd_setting"
    echo "  Delete branch with tree: $delete_branch_setting"
    echo
    echo "Settings will take effect next time you use gwt."
    return 0
  }

  __gwt_help() {
    cat << 'EOF'
gwt - Git Worktree Manager

USAGE:
    gwt <command> [options] [arguments]

DESCRIPTION:
    An opinionated git worktree manager that organizes worktrees in a sane
    default location: ~/worktrees/<owner>/<repo>/<branch> (or ~/worktrees/<repo>/<branch> if owner cannot be determined)

COMMANDS:
    add, a <branch>          Create a worktree for the specified branch
    cd, co [branch]          Change to worktree directory (or main if no branch)
    remove, rm <branch|path> Remove a worktree by branch name or path
    status, s                Show status of all worktrees
    clean                    Remove all linked worktrees
    init                     Initialize user settings
    --help                   Show this help message

ADD OPTIONS:
    -b                       Create the branch if it doesn't exist
    --cd                     Automatically cd to worktree after creation
    --no-cd                  Don't cd to worktree (overrides autoCd setting)
    --path, -p <path>        Use custom path instead of default location

REMOVE OPTIONS:
    --force, -f              Force removal even if dirty or has unpushed changes
    --delete-branch, -db     Delete the branch after removing worktree
                             (uses 'git branch -d', or 'git branch -D' with --force)
    --preserve-branch, -pb   Keep the branch (overrides deleteBranchWithTree setting)

STATUS OPTIONS:
    --with-main, -m          Include main worktree in output and show TYPE column
    --porcelain              Remove column headers for machine readability

GLOBAL OPTIONS:
    --dry-run                Show commands that would be executed without running them

EXAMPLES:
    gwt add -b feature --cd          Create new branch and worktree, then cd to it
    gwt status -m                    Show all worktrees including main
    gwt rm feature                   Remove worktree for 'feature' branch
    gwt rm . --delete-branch         Remove current worktree and its branch
    gwt rm feature -db -f            Force remove worktree and force delete branch
    gwt clean --dry-run              Preview removal of all linked worktrees
    gwt init                         Configure default settings

CONFIGURATION:
    Run 'gwt init' to set up persistent settings in ~/.config/gwt/settings.json:
    - worktreeLocation: Default base path for worktrees
    - autoCd: Automatically cd after creating worktrees
    - deleteBranchWithTree: Auto-delete branches when removing worktrees

REQUIREMENTS:
    - Must be run from within a git repository
    - 'jq' command required for gwt init
EOF
  }

  case $subcommand in
    add|a)
      __gwt_create "${(@)params}"
      ;;
    cd|co) # If a worktree exists, we treat cd and checkout as the same operation for convenience
      __gwt_cd "${(@)params}"
      ;;
    remove|rm)
      __gwt_remove "${(@)params}"
      ;;
    clean)
      __gwt_clean "${(@)params}"
      ;;
    init)
      __gwt_init "${(@)params}"
      ;;
    --help)
      __gwt_help
      ;;
    status|s|st|'')
      __gwt_status "${(@)params}"
      ;;
  esac
}

# Tab completion setup
if [[ -n "$ZSH_VERSION" ]] && (( $+functions[compdef] )); then
  _gwt() {
    local curcontext="$curcontext" state line
    typeset -A opt_args

    # Define the main subcommands
    local -a subcommands
    subcommands=(
        'add:Create a worktree for the specified branch'
        'cd:Change to worktree directory'
        'remove:Remove a worktree'
        'status:Show status of all worktrees'
        'clean:Remove all linked worktrees'
        'init:Initialize user settings'
    )

    # Main argument parsing
    _arguments -C \
        '1:command:->command' \
        '*::arg:->args'

    case $state in
        command)
            _describe -t commands 'gwt command' subcommands
            ;;
        args)
            case $line[1] in
                cd|co)
                    _gwt_complete_worktree_branches
                    ;;
                add|a)
                    _gwt_complete_add_command
                    ;;
                remove|rm)
                    _gwt_complete_worktree_branches_or_path
                    ;;
                status|s|st)
                    # No specific completions for status
                    ;;
                clean)
                    # No specific completions for clean
                    ;;
                init)
                    # No specific completions for init
                    ;;
            esac
            ;;
    esac
  }

  # Complete existing worktree branches
  _gwt_complete_worktree_branches() {
    local -a worktree_branches

    # Check if we're in a git repository
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        return 1
    fi

    # Get main repo path to exclude it
    local main_repo=""
    while IFS= read -r worktree_line; do
        local wt_path="$(echo "$worktree_line" | awk '{print $1}')"
        if [[ -n "$wt_path" && -d "$wt_path/.git" ]]; then
            main_repo="$wt_path"
            break
        fi
    done < <(git worktree list)

    # Get worktree branches using git worktree list
    git worktree list --porcelain | awk -v main_path="$main_repo" '
        /^worktree / { wt_path = substr($0, 10) }
        /^branch / { branch = substr($0, 8); gsub(/^refs\/heads\//, "", branch) }
        /^$/ {
            if (wt_path && branch && wt_path != main_path) {
                print branch
            }
            wt_path=""; branch=""
        }
        END {
            if (wt_path && branch && wt_path != main_path) {
                print branch
            }
        }
    ' | while read branch; do
        worktree_branches+=("$branch")
    done

    _describe -t branches 'worktree branch' worktree_branches
  }

  # Complete for add command
  _gwt_complete_add_command() {
    _gwt_complete_git_branches
  }

  # Complete git branches (excluding those with worktrees)
  _gwt_complete_git_branches() {
    local -a branches worktree_branches

    # Check if we're in a git repository
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        return 1
    fi

    # Get all branches
    branches=(${(f)"$(git branch --format='%(refname:short)' 2>/dev/null)"})

    # Get main repo path to exclude it
    local main_repo=""
    while IFS= read -r worktree_line; do
        local wt_path="$(echo "$worktree_line" | awk '{print $1}')"
        if [[ -n "$wt_path" && -d "$wt_path/.git" ]]; then
            main_repo="$wt_path"
            break
        fi
    done < <(git worktree list)

    # Get branches that already have worktrees
    git worktree list --porcelain | awk -v main_path="$main_repo" '
        /^worktree / { wt_path = substr($0, 10) }
        /^branch / { branch = substr($0, 8); gsub(/^refs\/heads\//, "", branch) }
        /^$/ {
            if (wt_path && branch && wt_path != main_path) {
                print branch
            }
            wt_path=""; branch=""
        }
        END {
            if (wt_path && branch && wt_path != main_path) {
                print branch
            }
        }
    ' | while read branch; do
        worktree_branches+=("$branch")
    done

    # Filter out branches that already have worktrees
    local -a available_branches
    for branch in "${branches[@]}"; do
        if ! (( ${worktree_branches[(Ie)$branch]} )); then
            available_branches+=("$branch")
        fi
    done

    # Also include remote branches
    local -a remote_branches
    remote_branches=(${(f)"$(git branch -r --format='%(refname:short)' 2>/dev/null | grep -v HEAD | sed 's|origin/||')"})

    # Add unique remote branches
    for branch in "${remote_branches[@]}"; do
        if ! (( ${available_branches[(Ie)$branch]} )) && ! (( ${worktree_branches[(Ie)$branch]} )); then
            available_branches+=("$branch")
        fi
    done

    _describe -t branches 'git branch' available_branches
  }

  # Complete worktree branches or current directory path
  _gwt_complete_worktree_branches_or_path() {
    _gwt_complete_worktree_branches_or_dot
  }

  # Complete worktree branches or "."
  _gwt_complete_worktree_branches_or_dot() {
    local -a worktree_branches

    # Check if we're in a git repository
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        return 1
    fi

    # Get main repo path to exclude it
    local main_repo=""
    while IFS= read -r worktree_line; do
        local wt_path="$(echo "$worktree_line" | awk '{print $1}')"
        if [[ -n "$wt_path" && -d "$wt_path/.git" ]]; then
            main_repo="$wt_path"
            break
        fi
    done < <(git worktree list)

    # Get worktree branches using git worktree list
    git worktree list --porcelain | awk -v main_path="$main_repo" '
        /^worktree / { wt_path = substr($0, 10) }
        /^branch / { branch = substr($0, 8); gsub(/^refs\/heads\//, "", branch) }
        /^$/ {
            if (wt_path && branch && wt_path != main_path) {
                print branch
            }
            wt_path=""; branch=""
        }
        END {
            if (wt_path && branch && wt_path != main_path) {
                print branch
            }
        }
    ' | while read branch; do
        worktree_branches+=("$branch")
    done

    _describe -t branches 'worktree branch' worktree_branches
  }

  compdef _gwt gwt
fi

# Call the function if script is executed directly
if [[ "${(%):-%x}" == "${0}" ]]; then
  gwt "$@"
fi

